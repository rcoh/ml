~!~$start_repo test_folders ~!~$stop ~!~$start_folder . ~!~$stop ~!~$start_file index . js ~!~$stop  ' use ~!~$spc strict  '  ; ~!~$spc var ~!~$spc crypto ~!~$spc  = ~!~$spc require  (  ' crypto  '  )  ; ~!~$spc  /  *  * ~!~$spc  * ~!~$spc convert ~!~$spc an ~!~$spc integer ~!~$spc to ~!~$spc a ~!~$spc byte ~!~$spc array ~!~$spc  * ~!~$spc  @ param ~!~$spc  {  integer  } ~!~$spc num ~!~$spc  * ~!~$spc  @ return ~!~$spc  {  array  } ~!~$spc bytes ~!~$spc  *  / ~!~$spc function ~!~$spc int to bytes  ( num  ) ~!~$spc  { ~!~$spc var ~!~$spc bytes ~!~$spc  = ~!~$spc  [  ]  ; ~!~$spc for  ( var ~!~$spc i  =  7 ~!~$spc  ; ~!~$spc i  >  =  0 ~!~$spc  ; ~!~$spc  -  - i  ) ~!~$spc  { ~!~$spc bytes  [ i  ] ~!~$spc  = ~!~$spc num ~!~$spc  & ~!~$spc  (  2 5 5  )  ; ~!~$spc num ~!~$spc  = ~!~$spc num ~!~$spc  >  > ~!~$spc  8  ; ~!~$spc  } ~!~$spc return ~!~$spc bytes  ; ~!~$spc  } ~!~$spc  /  *  * ~!~$spc  * ~!~$spc convert ~!~$spc a ~!~$spc hex ~!~$spc value ~!~$spc to ~!~$spc a ~!~$spc byte ~!~$spc array ~!~$spc  * ~!~$spc  @ param ~!~$spc  {  string  } ~!~$spc hex ~!~$spc string ~!~$spc of ~!~$spc hex ~!~$spc to ~!~$spc convert ~!~$spc to ~!~$spc a ~!~$spc byte ~!~$spc array ~!~$spc  * ~!~$spc  @ return ~!~$spc  {  array  } ~!~$spc bytes ~!~$spc  *  / ~!~$spc function ~!~$spc hex to bytes  ( hex  ) ~!~$spc  { ~!~$spc var ~!~$spc bytes ~!~$spc  = ~!~$spc  [  ]  ; ~!~$spc for  ( var ~!~$spc c ~!~$spc  = ~!~$spc  0  , ~!~$spc ~!~$all_caps c ~!~$spc  = ~!~$spc hex  . length  ; ~!~$spc c ~!~$spc  < ~!~$spc ~!~$all_caps c  ; ~!~$spc c ~!~$spc  +  = ~!~$spc  2  ) ~!~$spc  { ~!~$spc bytes  . push  ( parse int  ( hex  . substr  ( c  , ~!~$spc  2  )  , ~!~$spc  1 6  )  )  ; ~!~$spc  } ~!~$spc return ~!~$spc bytes  ; ~!~$spc  } ~!~$spc var ~!~$spc hotp ~!~$spc  = ~!~$spc  {  }  ; ~!~$spc  /  *  * ~!~$spc  * ~!~$spc  generate ~!~$spc a ~!~$spc counter ~!~$spc based ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc  * ~!~$spc  * ~!~$spc  @ return ~!~$spc  {  string  } ~!~$spc the ~!~$spc one ~!~$spc time ~!~$spc password ~!~$spc  * ~!~$spc  * ~!~$spc  arguments  : ~!~$spc  * ~!~$spc  * ~!~$spc args ~!~$spc  * ~!~$spc key ~!~$spc  - ~!~$spc  key ~!~$spc for ~!~$spc the ~!~$spc one ~!~$spc time ~!~$spc password  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc unique ~!~$spc and ~!~$spc secret ~!~$spc for ~!~$spc  * ~!~$spc every ~!~$spc user ~!~$spc as ~!~$spc this ~!~$spc is ~!~$spc the ~!~$spc seed ~!~$spc that ~!~$spc is ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc the ~!~$spc ~!~$all_caps hmac ~!~$spc  * ~!~$spc  * ~!~$spc counter ~!~$spc  - ~!~$spc  counter ~!~$spc value  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc stored ~!~$spc by ~!~$spc the ~!~$spc application  , ~!~$spc must ~!~$spc  * ~!~$spc be ~!~$spc user ~!~$spc specific  , ~!~$spc and ~!~$spc be ~!~$spc incremented ~!~$spc for ~!~$spc each ~!~$spc request  . ~!~$spc  * ~!~$spc  *  / ~!~$spc hotp  . gen ~!~$spc  = ~!~$spc function  ( key  , ~!~$spc opt  ) ~!~$spc  { ~!~$spc key ~!~$spc  = ~!~$spc key ~!~$spc  |  | ~!~$spc  '  '  ; ~!~$spc opt ~!~$spc  = ~!~$spc opt ~!~$spc  |  | ~!~$spc  {  }  ; ~!~$spc var ~!~$spc counter ~!~$spc  = ~!~$spc opt  . counter ~!~$spc  |  | ~!~$spc  0  ; ~!~$spc var ~!~$spc p ~!~$spc  = ~!~$spc  6  ; ~!~$spc  /  / ~!~$spc  create ~!~$spc the ~!~$spc byte ~!~$spc array ~!~$spc var ~!~$spc b ~!~$spc  = ~!~$spc new ~!~$spc  buffer  ( int to bytes  ( counter  )  )  ; ~!~$spc var ~!~$spc hmac ~!~$spc  = ~!~$spc crypto  . create hmac  (  ' sha 1  '  , ~!~$spc new ~!~$spc  buffer  ( key  )  )  ; ~!~$spc  /  / ~!~$spc  update ~!~$spc the ~!~$spc ~!~$all_caps hmac ~!~$spc with ~!~$spc the ~!~$spc byte ~!~$spc array ~!~$spc var ~!~$spc digest ~!~$spc  = ~!~$spc hmac  . update  ( b  )  . digest  (  ' hex  '  )  ; ~!~$spc  /  / ~!~$spc  get ~!~$spc byte ~!~$spc array ~!~$spc var ~!~$spc h ~!~$spc  = ~!~$spc hex to bytes  ( digest  )  ; ~!~$spc  /  / ~!~$spc  truncate ~!~$spc var ~!~$spc offset ~!~$spc  = ~!~$spc h  [  1 9  ] ~!~$spc  & ~!~$spc  0xf  ; ~!~$spc var ~!~$spc v ~!~$spc  = ~!~$spc  ( h  [ offset  ] ~!~$spc  & ~!~$spc  0x 7f  ) ~!~$spc  <  < ~!~$spc  2 4 ~!~$spc  | ~!~$spc  ( h  [ offset ~!~$spc  + ~!~$spc  1  ] ~!~$spc  & ~!~$spc  0xff  ) ~!~$spc  <  < ~!~$spc  1 6 ~!~$spc  | ~!~$spc  ( h  [ offset ~!~$spc  + ~!~$spc  2  ] ~!~$spc  & ~!~$spc  0xff  ) ~!~$spc  <  < ~!~$spc  8 ~!~$spc  | ~!~$spc  ( h  [ offset ~!~$spc  + ~!~$spc  3  ] ~!~$spc  & ~!~$spc  0xff  )  ; ~!~$spc v ~!~$spc  = ~!~$spc  ( v ~!~$spc  % ~!~$spc  1 0 0 0 0 0 0  ) ~!~$spc  + ~!~$spc  '  '  ; ~!~$spc return ~!~$spc  array  (  7  - v  . length  )  . join  (  '  0  '  ) ~!~$spc  + ~!~$spc v  ; ~!~$spc  }  ; ~!~$spc  /  *  * ~!~$spc  * ~!~$spc  check ~!~$spc a ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc based ~!~$spc on ~!~$spc a ~!~$spc counter  . ~!~$spc  * ~!~$spc  * ~!~$spc  @ return ~!~$spc  {  object  } ~!~$spc null ~!~$spc if ~!~$spc failure  , ~!~$spc  { ~!~$spc delta  : ~!~$spc  # ~!~$spc  } ~!~$spc on ~!~$spc success ~!~$spc  * ~!~$spc delta ~!~$spc is ~!~$spc the ~!~$spc time ~!~$spc step ~!~$spc difference ~!~$spc between ~!~$spc the ~!~$spc client ~!~$spc and ~!~$spc the ~!~$spc server ~!~$spc  * ~!~$spc  * ~!~$spc  arguments  : ~!~$spc  * ~!~$spc  * ~!~$spc args ~!~$spc  * ~!~$spc key ~!~$spc  - ~!~$spc  key ~!~$spc for ~!~$spc the ~!~$spc one ~!~$spc time ~!~$spc password  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc unique ~!~$spc and ~!~$spc secret ~!~$spc for ~!~$spc  * ~!~$spc every ~!~$spc user ~!~$spc as ~!~$spc it ~!~$spc is ~!~$spc the ~!~$spc seed ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc the ~!~$spc ~!~$all_caps hmac ~!~$spc  * ~!~$spc  * ~!~$spc token ~!~$spc  - ~!~$spc  passcode ~!~$spc to ~!~$spc validate  . ~!~$spc  * ~!~$spc  * ~!~$spc window ~!~$spc  - ~!~$spc  the ~!~$spc allowable ~!~$spc margin ~!~$spc for ~!~$spc the ~!~$spc counter  . ~!~$spc  the ~!~$spc function ~!~$spc will ~!~$spc check ~!~$spc  * ~!~$spc  ' ~!~$all_caps w  ' ~!~$spc codes ~!~$spc in ~!~$spc the ~!~$spc future ~!~$spc against ~!~$spc the ~!~$spc provided ~!~$spc passcode  . ~!~$spc  note  , ~!~$spc  * ~!~$spc it ~!~$spc is ~!~$spc the ~!~$spc calling ~!~$spc applications ~!~$spc responsibility ~!~$spc to ~!~$spc keep ~!~$spc track ~!~$spc of ~!~$spc  * ~!~$spc  ' ~!~$all_caps w  ' ~!~$spc and ~!~$spc increment ~!~$spc it ~!~$spc for ~!~$spc each ~!~$spc password ~!~$spc check  , ~!~$spc and ~!~$spc also ~!~$spc to ~!~$spc adjust ~!~$spc  * ~!~$spc it ~!~$spc accordingly ~!~$spc in ~!~$spc the ~!~$spc case ~!~$spc where ~!~$spc the ~!~$spc client ~!~$spc and ~!~$spc server ~!~$spc become ~!~$spc  * ~!~$spc out ~!~$spc of ~!~$spc sync ~!~$spc  ( second ~!~$spc argument ~!~$spc returns ~!~$spc non ~!~$spc zero  )  . ~!~$spc  * ~!~$spc ~!~$all_caps e  . g  . ~!~$spc if ~!~$spc ~!~$all_caps w ~!~$spc  = ~!~$spc  1 0 0  , ~!~$spc and ~!~$spc ~!~$all_caps c ~!~$spc  = ~!~$spc  5  , ~!~$spc this ~!~$spc function ~!~$spc will ~!~$spc check ~!~$spc the ~!~$spc passcode ~!~$spc  * ~!~$spc against ~!~$spc all ~!~$spc  one ~!~$spc  time ~!~$spc  passcodes ~!~$spc between ~!~$spc  5 ~!~$spc and ~!~$spc  1 0 5  . ~!~$spc  * ~!~$spc  * ~!~$spc  default ~!~$spc  - ~!~$spc  5 0 ~!~$spc  * ~!~$spc  * ~!~$spc counter ~!~$spc  - ~!~$spc  counter ~!~$spc value  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc stored ~!~$spc by ~!~$spc the ~!~$spc application  , ~!~$spc must ~!~$spc  * ~!~$spc be ~!~$spc user ~!~$spc specific  , ~!~$spc and ~!~$spc be ~!~$spc incremented ~!~$spc for ~!~$spc each ~!~$spc request  . ~!~$spc  * ~!~$spc  *  / ~!~$spc hotp  . verify ~!~$spc  = ~!~$spc function  ( token  , ~!~$spc key  , ~!~$spc opt  ) ~!~$spc  { ~!~$spc opt ~!~$spc  = ~!~$spc opt ~!~$spc  |  | ~!~$spc  {  }  ; ~!~$spc var ~!~$spc window ~!~$spc  = ~!~$spc opt  . window ~!~$spc  |  | ~!~$spc  5 0  ; ~!~$spc var ~!~$spc counter ~!~$spc  = ~!~$spc opt  . counter ~!~$spc  |  | ~!~$spc  0  ; ~!~$spc  /  / ~!~$spc  now ~!~$spc loop ~!~$spc through ~!~$spc from ~!~$spc ~!~$all_caps c ~!~$spc to ~!~$spc ~!~$all_caps c ~!~$spc  + ~!~$spc ~!~$all_caps w ~!~$spc to ~!~$spc determine ~!~$spc if ~!~$spc there ~!~$spc is ~!~$spc  /  / ~!~$spc a ~!~$spc correct ~!~$spc code ~!~$spc for  ( var ~!~$spc i ~!~$spc  = ~!~$spc counter ~!~$spc  - ~!~$spc window  ; ~!~$spc i ~!~$spc  <  = ~!~$spc counter ~!~$spc  + ~!~$spc window  ; ~!~$spc  +  + i  ) ~!~$spc  { ~!~$spc opt  . counter ~!~$spc  = ~!~$spc i  ; ~!~$spc if  (  ( this  . gen  ( key  , ~!~$spc opt  ) ~!~$spc  ^ ~!~$spc token  ) ~!~$spc  =  =  = ~!~$spc  0  ) ~!~$spc  { ~!~$spc  /  / ~!~$spc  we ~!~$spc have ~!~$spc found ~!~$spc a ~!~$spc matching ~!~$spc code  , ~!~$spc trigger ~!~$spc callback ~!~$spc  /  / ~!~$spc and ~!~$spc pass ~!~$spc offset ~!~$spc return ~!~$spc  { ~!~$spc delta  : ~!~$spc i ~!~$spc  - ~!~$spc counter ~!~$spc  }  ; ~!~$spc  } ~!~$spc  } ~!~$spc  /  / ~!~$spc  if ~!~$spc we ~!~$spc get ~!~$spc to ~!~$spc here ~!~$spc then ~!~$spc no ~!~$spc codes ~!~$spc have ~!~$spc matched  , ~!~$spc return ~!~$spc null ~!~$spc return ~!~$spc null  ; ~!~$spc  }  ; ~!~$spc var ~!~$spc totp ~!~$spc  = ~!~$spc  {  }  ; ~!~$spc  /  *  * ~!~$spc  * ~!~$spc  generate ~!~$spc a ~!~$spc time ~!~$spc based ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc  * ~!~$spc  * ~!~$spc  @ return ~!~$spc  {  string  } ~!~$spc the ~!~$spc one ~!~$spc time ~!~$spc password ~!~$spc  * ~!~$spc  * ~!~$spc  arguments  : ~!~$spc  * ~!~$spc  * ~!~$spc args ~!~$spc  * ~!~$spc key ~!~$spc  - ~!~$spc  key ~!~$spc for ~!~$spc the ~!~$spc one ~!~$spc time ~!~$spc password  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc unique ~!~$spc and ~!~$spc secret ~!~$spc for ~!~$spc  * ~!~$spc every ~!~$spc user ~!~$spc as ~!~$spc it ~!~$spc is ~!~$spc the ~!~$spc seed ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc the ~!~$spc ~!~$all_caps hmac ~!~$spc  * ~!~$spc  * ~!~$spc time ~!~$spc  - ~!~$spc  the ~!~$spc time ~!~$spc step ~!~$spc of ~!~$spc the ~!~$spc counter  . ~!~$spc  this ~!~$spc must ~!~$spc be ~!~$spc the ~!~$spc same ~!~$spc for ~!~$spc  * ~!~$spc every ~!~$spc request ~!~$spc and ~!~$spc is ~!~$spc used ~!~$spc to ~!~$spc calculat ~!~$spc ~!~$all_caps c  . ~!~$spc  * ~!~$spc  * ~!~$spc  default ~!~$spc  - ~!~$spc  3 0 ~!~$spc  * ~!~$spc  *  / ~!~$spc totp  . gen ~!~$spc  = ~!~$spc function  ( key  , ~!~$spc opt  ) ~!~$spc  { ~!~$spc opt ~!~$spc  = ~!~$spc opt ~!~$spc  |  | ~!~$spc  {  }  ; ~!~$spc var ~!~$spc time ~!~$spc  = ~!~$spc opt  . time ~!~$spc  |  | ~!~$spc  3 0  ; ~!~$spc var ~!~$spc   t ~!~$spc  = ~!~$spc  date  . now  (  )  ; ~!~$spc  /  / ~!~$spc  time ~!~$spc has ~!~$spc been ~!~$spc overwritten  . ~!~$spc if  ( opt  .   t  ) ~!~$spc  { ~!~$spc if  ( process  . env  . ~!~$all_caps node   ~!~$all_caps env ~!~$spc  !  = ~!~$spc  ' test  '  ) ~!~$spc  { ~!~$spc throw ~!~$spc new ~!~$spc  error  (  ' cannot ~!~$spc overwrite ~!~$spc time ~!~$spc in ~!~$spc non  - test ~!~$spc environment  !  '  )  ; ~!~$spc  } ~!~$spc   t ~!~$spc  = ~!~$spc opt  .   t  ; ~!~$spc  } ~!~$spc  /  / ~!~$spc  determine ~!~$spc the ~!~$spc value ~!~$spc of ~!~$spc the ~!~$spc counter  , ~!~$spc ~!~$all_caps c ~!~$spc  /  / ~!~$spc  this ~!~$spc is ~!~$spc the ~!~$spc number ~!~$spc of ~!~$spc time ~!~$spc steps ~!~$spc in ~!~$spc seconds ~!~$spc since ~!~$spc ~!~$all_caps  t 0 ~!~$spc opt  . counter ~!~$spc  = ~!~$spc  math  . floor  (  (   t ~!~$spc  / ~!~$spc  1 0 0 0  ) ~!~$spc  / ~!~$spc time  )  ; ~!~$spc return ~!~$spc hotp  . gen  ( key  , ~!~$spc opt  )  ; ~!~$spc  }  ; ~!~$spc  /  *  * ~!~$spc  * ~!~$spc  check ~!~$spc a ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc based ~!~$spc on ~!~$spc a ~!~$spc timer  . ~!~$spc  * ~!~$spc  * ~!~$spc  @ return ~!~$spc  {  object  } ~!~$spc null ~!~$spc if ~!~$spc failure  , ~!~$spc  { ~!~$spc delta  : ~!~$spc  # ~!~$spc  } ~!~$spc on ~!~$spc success ~!~$spc  * ~!~$spc delta ~!~$spc is ~!~$spc the ~!~$spc time ~!~$spc step ~!~$spc difference ~!~$spc between ~!~$spc the ~!~$spc client ~!~$spc and ~!~$spc the ~!~$spc server ~!~$spc  * ~!~$spc  * ~!~$spc  arguments  : ~!~$spc  * ~!~$spc  * ~!~$spc args ~!~$spc  * ~!~$spc key ~!~$spc  - ~!~$spc  key ~!~$spc for ~!~$spc the ~!~$spc one ~!~$spc time ~!~$spc password  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc unique ~!~$spc and ~!~$spc secret ~!~$spc for ~!~$spc  * ~!~$spc every ~!~$spc user ~!~$spc as ~!~$spc it ~!~$spc is ~!~$spc the ~!~$spc seed ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc the ~!~$spc ~!~$all_caps hmac ~!~$spc  * ~!~$spc  * ~!~$spc token ~!~$spc  - ~!~$spc  passcode ~!~$spc to ~!~$spc validate  . ~!~$spc  * ~!~$spc  * ~!~$spc window ~!~$spc  - ~!~$spc  the ~!~$spc allowable ~!~$spc margin ~!~$spc for ~!~$spc the ~!~$spc counter  . ~!~$spc  the ~!~$spc function ~!~$spc will ~!~$spc check ~!~$spc  * ~!~$spc  ' ~!~$all_caps w  ' ~!~$spc codes ~!~$spc either ~!~$spc side ~!~$spc of ~!~$spc the ~!~$spc provided ~!~$spc counter  . ~!~$spc  note  , ~!~$spc  * ~!~$spc it ~!~$spc is ~!~$spc the ~!~$spc calling ~!~$spc applications ~!~$spc responsibility ~!~$spc to ~!~$spc keep ~!~$spc track ~!~$spc of ~!~$spc  * ~!~$spc  ' ~!~$all_caps w  ' ~!~$spc and ~!~$spc increment ~!~$spc it ~!~$spc for ~!~$spc each ~!~$spc password ~!~$spc check  , ~!~$spc and ~!~$spc also ~!~$spc to ~!~$spc adjust ~!~$spc  * ~!~$spc it ~!~$spc accordingly ~!~$spc in ~!~$spc the ~!~$spc case ~!~$spc where ~!~$spc the ~!~$spc client ~!~$spc and ~!~$spc server ~!~$spc become ~!~$spc  * ~!~$spc out ~!~$spc of ~!~$spc sync ~!~$spc  ( second ~!~$spc argument ~!~$spc returns ~!~$spc non ~!~$spc zero  )  . ~!~$spc  * ~!~$spc ~!~$all_caps e  . g  . ~!~$spc if ~!~$spc ~!~$all_caps w ~!~$spc  = ~!~$spc  5  , ~!~$spc and ~!~$spc ~!~$all_caps c ~!~$spc  = ~!~$spc  1 0 0 0  , ~!~$spc this ~!~$spc function ~!~$spc will ~!~$spc check ~!~$spc the ~!~$spc passcode ~!~$spc  * ~!~$spc against ~!~$spc all ~!~$spc  one ~!~$spc  time ~!~$spc  passcodes ~!~$spc between ~!~$spc  9 9 5 ~!~$spc and ~!~$spc  1 0 0 5  . ~!~$spc  * ~!~$spc  * ~!~$spc  default ~!~$spc  - ~!~$spc  6 ~!~$spc  * ~!~$spc  * ~!~$spc time ~!~$spc  - ~!~$spc  the ~!~$spc time ~!~$spc step ~!~$spc of ~!~$spc the ~!~$spc counter  . ~!~$spc  this ~!~$spc must ~!~$spc be ~!~$spc the ~!~$spc same ~!~$spc for ~!~$spc  * ~!~$spc every ~!~$spc request ~!~$spc and ~!~$spc is ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc ~!~$all_caps c  . ~!~$spc  * ~!~$spc  * ~!~$spc  default ~!~$spc  - ~!~$spc  3 0 ~!~$spc  * ~!~$spc  *  / ~!~$spc totp  . verify ~!~$spc  = ~!~$spc function  ( token  , ~!~$spc key  , ~!~$spc opt  ) ~!~$spc  { ~!~$spc opt ~!~$spc  = ~!~$spc opt ~!~$spc  |  | ~!~$spc  {  }  ; ~!~$spc var ~!~$spc time ~!~$spc  = ~!~$spc opt  . time ~!~$spc  |  | ~!~$spc  3 0  ; ~!~$spc var ~!~$spc   t ~!~$spc  = ~!~$spc  date  . now  (  )  ; ~!~$spc  /  / ~!~$spc  time ~!~$spc has ~!~$spc been ~!~$spc overwritten  . ~!~$spc if  ( opt  .   t  ) ~!~$spc  { ~!~$spc if  ( process  . env  . ~!~$all_caps node   ~!~$all_caps env ~!~$spc  !  = ~!~$spc  ' test  '  ) ~!~$spc  { ~!~$spc throw ~!~$spc new ~!~$spc  error  (  ' cannot ~!~$spc overwrite ~!~$spc time ~!~$spc in ~!~$spc non  - test ~!~$spc environment  !  '  )  ; ~!~$spc  } ~!~$spc   t ~!~$spc  = ~!~$spc opt  .   t  ; ~!~$spc  } ~!~$spc  /  / ~!~$spc  determine ~!~$spc the ~!~$spc value ~!~$spc of ~!~$spc the ~!~$spc counter  , ~!~$spc ~!~$all_caps c ~!~$spc  /  / ~!~$spc  this ~!~$spc is ~!~$spc the ~!~$spc number ~!~$spc of ~!~$spc time ~!~$spc steps ~!~$spc in ~!~$spc seconds ~!~$spc since ~!~$spc ~!~$all_caps  t 0 ~!~$spc opt  . counter ~!~$spc  = ~!~$spc  math  . floor  (  (   t ~!~$spc  / ~!~$spc  1 0 0 0  ) ~!~$spc  / ~!~$spc time  )  ; ~!~$spc return ~!~$spc hotp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ; ~!~$spc  }  ; ~!~$spc module  . exports  . hotp ~!~$spc  = ~!~$spc hotp  ; ~!~$spc module  . exports  . totp ~!~$spc  = ~!~$spc totp  ; ~!~$spc ~!~$start_file Readme . md ~!~$stop  [  !  [  build ~!~$spc  status  ]  ( https  :  /  / travis  - ci  . org  / guyht  / notp  . svg  )  ]  ( https  :  /  / travis  - ci  . org  / guyht  / notp  ) ~!~$spc  # ~!~$spc  node ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc library ~!~$spc  simple ~!~$spc to ~!~$spc use  , ~!~$spc fast  , ~!~$spc and ~!~$spc with ~!~$spc zero ~!~$spc dependencies  . ~!~$spc  the ~!~$spc  node ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc library ~!~$spc is ~!~$spc fully ~!~$spc compliant ~!~$spc with ~!~$spc  [ ~!~$all_caps hotp  ]  ( http  :  /  / tools  . ietf  . org  / html  / rfc 4 2 2 6  ) ~!~$spc  ( counter ~!~$spc based ~!~$spc one ~!~$spc time ~!~$spc passwords  ) ~!~$spc and ~!~$spc  [ ~!~$all_caps totp  ]  ( http  :  /  / tools  . ietf  . org  / html  / rfc 6 2 3 8  ) ~!~$spc  ( time ~!~$spc based ~!~$spc one ~!~$spc time ~!~$spc passwords  )  . ~!~$spc  it ~!~$spc can ~!~$spc be ~!~$spc used ~!~$spc in ~!~$spc conjunction ~!~$spc with ~!~$spc the ~!~$spc  [  google ~!~$spc  authenticator  ]  ( https  :  /  / github  . com  / google  / google  - authenticator  /  ) ~!~$spc which ~!~$spc has ~!~$spc free ~!~$spc apps ~!~$spc for ~!~$spc i o s  , ~!~$spc  android ~!~$spc and ~!~$spc  black berry  . ~!~$spc  # ~!~$spc  installation ~!~$spc  `  `  ` ~!~$spc npm ~!~$spc install ~!~$spc notp ~!~$spc  `  `  ` ~!~$spc  # ~!~$spc  usage ~!~$spc  `  `  ` javascript ~!~$spc var ~!~$spc notp ~!~$spc  = ~!~$spc require  (  ' notp  '  )  ; ~!~$spc  /  /  .  .  .  . ~!~$spc some ~!~$spc initial ~!~$spc login ~!~$spc code  , ~!~$spc that ~!~$spc receives ~!~$spc the ~!~$spc user ~!~$spc details ~!~$spc and ~!~$spc ~!~$all_caps totp ~!~$spc  / ~!~$spc ~!~$all_caps hotp ~!~$spc token ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  ' secret ~!~$spc key ~!~$spc for ~!~$spc user  .  .  . ~!~$spc could ~!~$spc be ~!~$spc stored ~!~$spc in ~!~$spc ~!~$all_caps db  '  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  ' user ~!~$spc supplied ~!~$spc one ~!~$spc time ~!~$spc use ~!~$spc token  '  ; ~!~$spc  /  / ~!~$spc  check ~!~$spc ~!~$all_caps totp ~!~$spc is ~!~$spc correct ~!~$spc  ( ~!~$all_caps hotp ~!~$spc if ~!~$spc hotp ~!~$spc pass ~!~$spc type  ) ~!~$spc var ~!~$spc login ~!~$spc  = ~!~$spc notp  . totp  . verify  ( token  , ~!~$spc key  )  ; ~!~$spc  /  / ~!~$spc invalid ~!~$spc token ~!~$spc if ~!~$spc login ~!~$spc is ~!~$spc null ~!~$spc if ~!~$spc  (  ! login  ) ~!~$spc  { ~!~$spc return ~!~$spc console  . log  (  '  token ~!~$spc invalid  '  )  ; ~!~$spc  } ~!~$spc  /  / ~!~$spc valid ~!~$spc token ~!~$spc console  . log  (  '  token ~!~$spc valid  , ~!~$spc sync ~!~$spc value ~!~$spc is ~!~$spc  % s  '  , ~!~$spc login  . delta  )  ; ~!~$spc  `  `  ` ~!~$spc  #  # ~!~$spc  google ~!~$spc  authenticator ~!~$spc  [  google ~!~$spc authenticator  ]  ( https  :  /  / github  . com  / google  / google  - authenticator  /  ) ~!~$spc requires ~!~$spc that ~!~$spc keys ~!~$spc be ~!~$spc base 3 2 ~!~$spc encoded ~!~$spc before ~!~$spc being ~!~$spc used  . ~!~$spc  this ~!~$spc includes ~!~$spc manual ~!~$spc entry ~!~$spc into ~!~$spc the ~!~$spc app ~!~$spc as ~!~$spc well ~!~$spc as ~!~$spc preparing ~!~$spc a ~!~$spc ~!~$all_caps qr ~!~$spc code ~!~$spc ~!~$all_caps uri  . ~!~$spc  to ~!~$spc base 3 2 ~!~$spc encode ~!~$spc a ~!~$spc utf 8 ~!~$spc key ~!~$spc you ~!~$spc can ~!~$spc use ~!~$spc the ~!~$spc  ` thirty  - two  ` ~!~$spc module  . ~!~$spc  `  `  ` javascript ~!~$spc var ~!~$spc base 3 2 ~!~$spc  = ~!~$spc require  (  ' thirty  - two  '  )  ; ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  ' secret ~!~$spc key ~!~$spc for ~!~$spc the ~!~$spc user  '  ; ~!~$spc  /  / ~!~$spc encoded ~!~$spc will ~!~$spc be ~!~$spc the ~!~$spc secret ~!~$spc key  , ~!~$spc base 3 2 ~!~$spc encoded ~!~$spc var ~!~$spc encoded ~!~$spc  = ~!~$spc base 3 2  . encode  ( key  )  ; ~!~$spc  /  / ~!~$spc  google ~!~$spc authenticator ~!~$spc doesn  ' t ~!~$spc like ~!~$spc equal ~!~$spc signs ~!~$spc var ~!~$spc encoded for google ~!~$spc  = ~!~$spc encoded  . to string  (  )  . replace  (  /  =  / g  ,  '  '  )  ; ~!~$spc  /  / ~!~$spc to ~!~$spc create ~!~$spc a ~!~$spc ~!~$all_caps uri ~!~$spc for ~!~$spc a ~!~$spc qr ~!~$spc code ~!~$spc  ( change ~!~$spc totp ~!~$spc to ~!~$spc hotp ~!~$spc if ~!~$spc using ~!~$spc hotp  ) ~!~$spc var ~!~$spc uri ~!~$spc  = ~!~$spc  ' otpauth  :  /  / totp  / somelabel  ? secret  =  ' ~!~$spc  + ~!~$spc encoded for google  ; ~!~$spc  `  `  ` ~!~$spc  note  : ~!~$spc  if ~!~$spc your ~!~$spc label ~!~$spc has ~!~$spc spaces ~!~$spc or ~!~$spc other ~!~$spc invalid ~!~$spc uri ~!~$spc characters ~!~$spc you ~!~$spc will ~!~$spc need ~!~$spc to ~!~$spc encode ~!~$spc it ~!~$spc accordingly ~!~$spc using ~!~$spc  ` encode u r i component  ` ~!~$spc  more ~!~$spc details ~!~$spc about ~!~$spc the ~!~$spc uri ~!~$spc key ~!~$spc format ~!~$spc can ~!~$spc be ~!~$spc found ~!~$spc on ~!~$spc the ~!~$spc  [ google ~!~$spc auth ~!~$spc wiki  ]  ( https  :  /  / github  . com  / google  / google  - authenticator  / wiki  /  key  -  uri  -  format  ) ~!~$spc  # ~!~$spc ~!~$all_caps api ~!~$spc  #  # ~!~$spc hotp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  ) ~!~$spc  check ~!~$spc a ~!~$spc counter ~!~$spc based ~!~$spc one ~!~$spc time ~!~$spc password ~!~$spc for ~!~$spc validity  . ~!~$spc  returns ~!~$spc null ~!~$spc if ~!~$spc token ~!~$spc is ~!~$spc not ~!~$spc valid ~!~$spc for ~!~$spc given ~!~$spc key ~!~$spc and ~!~$spc options  . ~!~$spc  returns ~!~$spc an ~!~$spc object ~!~$spc  `  { delta  : ~!~$spc  #  }  ` ~!~$spc if ~!~$spc the ~!~$spc token ~!~$spc is ~!~$spc valid  . ~!~$spc  ` delta  ` ~!~$spc is ~!~$spc the ~!~$spc count ~!~$spc skew ~!~$spc between ~!~$spc client ~!~$spc and ~!~$spc server  . ~!~$spc  #  #  # ~!~$spc opt ~!~$spc  *  * window  *  * ~!~$spc  > ~!~$spc  the ~!~$spc allowable ~!~$spc margin ~!~$spc for ~!~$spc the ~!~$spc counter  . ~!~$spc  the ~!~$spc function ~!~$spc will ~!~$spc check ~!~$spc  ` window  ` ~!~$spc codes ~!~$spc in ~!~$spc the ~!~$spc future ~!~$spc against ~!~$spc the ~!~$spc provided ~!~$spc token  . ~!~$spc  > ~!~$spc i  . e  . ~!~$spc if ~!~$spc  ` window ~!~$spc  = ~!~$spc  1 0 0  ` ~!~$spc and ~!~$spc  ` counter ~!~$spc  = ~!~$spc  5  ` ~!~$spc all ~!~$spc tokens ~!~$spc between ~!~$spc  5 ~!~$spc and ~!~$spc  1 0 5 ~!~$spc will ~!~$spc be ~!~$spc checked ~!~$spc against ~!~$spc the ~!~$spc supplied ~!~$spc token ~!~$spc  > ~!~$spc  default ~!~$spc  - ~!~$spc  5 0 ~!~$spc  *  * counter  *  * ~!~$spc  > ~!~$spc  counter ~!~$spc value  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc stored ~!~$spc by ~!~$spc the ~!~$spc application ~!~$spc on ~!~$spc a ~!~$spc per ~!~$spc user ~!~$spc basis  . ~!~$spc  it ~!~$spc is ~!~$spc up ~!~$spc to ~!~$spc the ~!~$spc application ~!~$spc to ~!~$spc track ~!~$spc and ~!~$spc increment ~!~$spc this ~!~$spc value ~!~$spc as ~!~$spc needed  . ~!~$spc  it ~!~$spc is ~!~$spc also ~!~$spc up ~!~$spc to ~!~$spc the ~!~$spc application ~!~$spc to ~!~$spc increment ~!~$spc this ~!~$spc value ~!~$spc if ~!~$spc there ~!~$spc is ~!~$spc a ~!~$spc skew ~!~$spc between ~!~$spc the ~!~$spc client ~!~$spc and ~!~$spc server ~!~$spc  (  ` delta  `  ) ~!~$spc  #  # ~!~$spc totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  ) ~!~$spc  check ~!~$spc a ~!~$spc time ~!~$spc based ~!~$spc one ~!~$spc time ~!~$spc password ~!~$spc for ~!~$spc validity ~!~$spc  returns ~!~$spc null ~!~$spc if ~!~$spc token ~!~$spc is ~!~$spc not ~!~$spc valid ~!~$spc for ~!~$spc given ~!~$spc key ~!~$spc and ~!~$spc options  . ~!~$spc  returns ~!~$spc an ~!~$spc object ~!~$spc  `  { delta  : ~!~$spc  #  }  ` ~!~$spc if ~!~$spc the ~!~$spc token ~!~$spc is ~!~$spc valid  . ~!~$spc  ` delta  ` ~!~$spc is ~!~$spc the ~!~$spc count ~!~$spc skew ~!~$spc between ~!~$spc client ~!~$spc and ~!~$spc server  . ~!~$spc  #  #  # ~!~$spc opt ~!~$spc  *  * window  *  * ~!~$spc  > ~!~$spc  the ~!~$spc allowable ~!~$spc margin ~!~$spc for ~!~$spc the ~!~$spc counter  . ~!~$spc  the ~!~$spc function ~!~$spc will ~!~$spc check ~!~$spc  ` window  ` ~!~$spc codes ~!~$spc in ~!~$spc the ~!~$spc future ~!~$spc against ~!~$spc the ~!~$spc provided ~!~$spc token  . ~!~$spc  > ~!~$spc i  . e  . ~!~$spc if ~!~$spc  ` window ~!~$spc  = ~!~$spc  5  ` ~!~$spc and ~!~$spc  ` counter ~!~$spc  = ~!~$spc  1 0 0 0  ` ~!~$spc all ~!~$spc tokens ~!~$spc between ~!~$spc  9 9 5 ~!~$spc and ~!~$spc  1 0 0 5 ~!~$spc will ~!~$spc be ~!~$spc checked ~!~$spc against ~!~$spc the ~!~$spc supplied ~!~$spc token ~!~$spc  > ~!~$spc  default ~!~$spc  - ~!~$spc  6 ~!~$spc  *  * time  *  * ~!~$spc  > ~!~$spc  the ~!~$spc time ~!~$spc step ~!~$spc of ~!~$spc the ~!~$spc counter  . ~!~$spc  this ~!~$spc must ~!~$spc be ~!~$spc the ~!~$spc same ~!~$spc for ~!~$spc every ~!~$spc request ~!~$spc and ~!~$spc is ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc ~!~$all_caps c  . ~!~$spc  > ~!~$spc  default ~!~$spc  - ~!~$spc  3 0 ~!~$spc  #  # ~!~$spc hotp  . gen  ( key  , ~!~$spc opt  ) ~!~$spc  return ~!~$spc a ~!~$spc counter ~!~$spc based ~!~$spc one ~!~$spc time ~!~$spc password ~!~$spc  #  #  # ~!~$spc opt ~!~$spc  *  * counter  *  * ~!~$spc  > ~!~$spc  counter ~!~$spc value  . ~!~$spc  this ~!~$spc should ~!~$spc be ~!~$spc stored ~!~$spc by ~!~$spc the ~!~$spc application  , ~!~$spc must ~!~$spc be ~!~$spc user ~!~$spc specific  , ~!~$spc and ~!~$spc be ~!~$spc incremented ~!~$spc for ~!~$spc each ~!~$spc request  . ~!~$spc  #  # ~!~$spc totp  . gen  ( key  , ~!~$spc opt  ) ~!~$spc  return ~!~$spc a ~!~$spc time ~!~$spc based ~!~$spc one ~!~$spc time ~!~$spc password ~!~$spc  #  #  # ~!~$spc opt ~!~$spc  *  * time  *  * ~!~$spc  > ~!~$spc  the ~!~$spc time ~!~$spc step ~!~$spc of ~!~$spc the ~!~$spc counter  . ~!~$spc  this ~!~$spc must ~!~$spc be ~!~$spc the ~!~$spc same ~!~$spc for ~!~$spc every ~!~$spc request ~!~$spc and ~!~$spc is ~!~$spc used ~!~$spc to ~!~$spc calculate ~!~$spc ~!~$all_caps c  . ~!~$spc  > ~!~$spc  default ~!~$spc  - ~!~$spc  3 0 ~!~$spc  # ~!~$spc  migrating ~!~$spc from ~!~$spc  1  . x ~!~$spc to ~!~$spc  2  . x ~!~$spc  #  # ~!~$spc  removed ~!~$spc  the ~!~$spc  ` enc base 3 2  ` ~!~$spc and ~!~$spc  ` dec base 3 2  ` ~!~$spc methods ~!~$spc have ~!~$spc been ~!~$spc removed  . ~!~$spc  if ~!~$spc you ~!~$spc wish ~!~$spc to ~!~$spc encode  / decode ~!~$spc base 3 2 ~!~$spc you ~!~$spc should ~!~$spc install ~!~$spc a ~!~$spc module ~!~$spc to ~!~$spc do ~!~$spc so  . ~!~$spc  we ~!~$spc recommend ~!~$spc the ~!~$spc  ` thirty  - two  ` ~!~$spc npm ~!~$spc module  . ~!~$spc  #  # ~!~$spc  changed ~!~$spc  all ~!~$spc of ~!~$spc the ~!~$spc  a p is ~!~$spc have ~!~$spc been ~!~$spc changed ~!~$spc to ~!~$spc return ~!~$spc values ~!~$spc directly ~!~$spc instead ~!~$spc of ~!~$spc using ~!~$spc callbacks  . ~!~$spc  this ~!~$spc reflects ~!~$spc the ~!~$spc fact ~!~$spc that ~!~$spc the ~!~$spc functions ~!~$spc are ~!~$spc actually ~!~$spc synchronous ~!~$spc and ~!~$spc perform ~!~$spc no ~!~$spc ~!~$all_caps i  / ~!~$all_caps o  . ~!~$spc  some ~!~$spc of ~!~$spc the ~!~$spc required ~!~$spc arguments ~!~$spc to ~!~$spc the ~!~$spc functions ~!~$spc have ~!~$spc also ~!~$spc been ~!~$spc removed ~!~$spc from ~!~$spc the ~!~$spc  ` args  ` ~!~$spc parameter ~!~$spc and ~!~$spc are ~!~$spc passed ~!~$spc as ~!~$spc separate ~!~$spc function ~!~$spc parameters  . ~!~$spc  see ~!~$spc the ~!~$spc above ~!~$spc ~!~$all_caps api ~!~$spc docs ~!~$spc for ~!~$spc details  . ~!~$spc  * ~!~$spc  ` notp  . check h o t p  ( args  , ~!~$spc err  , ~!~$spc cb  )  ` ~!~$spc  -  > ~!~$spc  ` notp  . hotp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ` ~!~$spc  * ~!~$spc  ` notp  . check t o t p  ( args  , ~!~$spc err  , ~!~$spc cb  )  ` ~!~$spc  -  > ~!~$spc  ` notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ` ~!~$spc  * ~!~$spc  ` notp  . get h o t p  ( args  , ~!~$spc err  , ~!~$spc cb  )  ` ~!~$spc  -  > ~!~$spc  ` notp  . gotp  . gen  ( key  , ~!~$spc opt  )  ` ~!~$spc  * ~!~$spc  ` notp  . get t o t p  ( args  , ~!~$spc err  , ~!~$spc cb  )  ` ~!~$spc  -  > ~!~$spc  ` notp  . totp  . gen  ( key  , ~!~$spc opt  )  ` ~!~$spc  #  # ~!~$spc  args ~!~$spc  the ~!~$spc argument ~!~$spc names ~!~$spc have ~!~$spc also ~!~$spc changed ~!~$spc to ~!~$spc better ~!~$spc describe ~!~$spc the ~!~$spc purpose ~!~$spc of ~!~$spc the ~!~$spc argument  . ~!~$spc  * ~!~$spc  ` ~!~$all_caps k  ` ~!~$spc  -  > ~!~$spc no ~!~$spc longer ~!~$spc in ~!~$spc args  / opt ~!~$spc but ~!~$spc passed ~!~$spc directly ~!~$spc as ~!~$spc a ~!~$spc function ~!~$spc argument ~!~$spc  * ~!~$spc  ` ~!~$all_caps p  ` ~!~$spc  -  > ~!~$spc no ~!~$spc longer ~!~$spc in ~!~$spc args  / opt ~!~$spc but ~!~$spc passed ~!~$spc directly ~!~$spc as ~!~$spc a ~!~$spc function ~!~$spc argument ~!~$spc  * ~!~$spc  ` ~!~$all_caps w  ` ~!~$spc  -  > ~!~$spc  ` window  ` ~!~$spc  * ~!~$spc  ` ~!~$all_caps c  ` ~!~$spc  -  > ~!~$spc  ` counter  ` ~!~$spc  * ~!~$spc  ` ~!~$all_caps t  ` ~!~$spc  -  > ~!~$spc  ` time  ` ~!~$spc ~!~$start_file package . json ~!~$stop  { ~!~$spc  " author  "  : ~!~$spc  "  guy ~!~$spc  halford  -  thompson ~!~$spc  < guy  @ guy  . ht  > ~!~$spc  ( http  :  /  / guy  . ht  )  "  , ~!~$spc  " name  "  : ~!~$spc  " notp  "  , ~!~$spc  " description  "  : ~!~$spc  "  node ~!~$spc  one ~!~$spc  time ~!~$spc  password ~!~$spc library  , ~!~$spc supports ~!~$spc ~!~$all_caps hotp  , ~!~$spc ~!~$all_caps totp ~!~$spc and ~!~$spc works ~!~$spc with ~!~$spc  google ~!~$spc  authenticator  "  , ~!~$spc  " version  "  : ~!~$spc  "  2  .  0  .  3  "  , ~!~$spc  " homepage  "  : ~!~$spc  " https  :  /  / github  . com  / guyht  / notp  "  , ~!~$spc  " repository  "  : ~!~$spc  { ~!~$spc  " type  "  : ~!~$spc  " git  "  , ~!~$spc  " url  "  : ~!~$spc  " git  :  /  / github  . com  / guyht  / notp  . git  " ~!~$spc  }  , ~!~$spc  " main  "  : ~!~$spc  " index  . js  "  , ~!~$spc  " scripts  "  : ~!~$spc  { ~!~$spc  " test  "  : ~!~$spc  " ~!~$all_caps node   ~!~$all_caps env  = test ~!~$spc mocha  " ~!~$spc  }  , ~!~$spc  " engines  "  : ~!~$spc  { ~!~$spc  " node  "  : ~!~$spc  "  > ~!~$spc v 0  .  6  .  0  " ~!~$spc  }  , ~!~$spc  " dependencies  "  : ~!~$spc  {  }  , ~!~$spc  " dev dependencies  "  : ~!~$spc  { ~!~$spc  " mocha  "  : ~!~$spc  "  ~  1  .  1 8  .  2  "  , ~!~$spc  " thirty  - two  "  : ~!~$spc  "  0  .  0  .  2  " ~!~$spc  } ~!~$spc  } ~!~$spc ~!~$start_folder test ~!~$stop ~!~$start_file test / notp . js ~!~$stop var ~!~$spc notp ~!~$spc  = ~!~$spc require  (  '  .  .  '  )  ; ~!~$spc var ~!~$spc assert ~!~$spc  = ~!~$spc require  (  ' assert  '  )  ; ~!~$spc  /  * ~!~$spc  * ~!~$spc  test ~!~$spc  h o ttoken  . ~!~$spc  uses ~!~$spc test ~!~$spc values ~!~$spc from ~!~$spc  r fcounter ~!~$spc  4 2 2 6 ~!~$spc  * ~!~$spc  * ~!~$spc  * ~!~$spc  the ~!~$spc following ~!~$spc test ~!~$spc data ~!~$spc uses ~!~$spc the ~!~$spc  a scounter i i ~!~$spc string ~!~$spc  * ~!~$spc  "  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  " ~!~$spc for ~!~$spc the ~!~$spc secret  : ~!~$spc  * ~!~$spc  * ~!~$spc  secret ~!~$spc  = ~!~$spc  0x 3 1 3 2 3 3 3 4 3 5 3 6 3 7 3 8 3 9 3 0 3 1 3 2 3 3 3 4 3 5 3 6 3 7 3 8 3 9 3 0 ~!~$spc  * ~!~$spc  * ~!~$spc  table ~!~$spc  1 ~!~$spc details ~!~$spc for ~!~$spc each ~!~$spc count  , ~!~$spc the ~!~$spc intermediate ~!~$spc  h m acounter ~!~$spc value  . ~!~$spc  * ~!~$spc  * ~!~$spc counterount ~!~$spc  hexadecimal ~!~$spc  h m acounter  - ~!~$all_caps sha  -  1  ( secret  , ~!~$spc count  ) ~!~$spc  * ~!~$spc  0 ~!~$spc cc 9 3cf 1 8 5 0 8d 9 4 9 3 4c 6 4b 6 5d 8ba 7 6 6 7fb 7cde 4b 0 ~!~$spc  * ~!~$spc  1 ~!~$spc  7 5a 4 8a 1 9d 4cbe 1 0 0 6 4 4e 8ac 1 3 9 7eea 7 4 7a 2d 3 3ab ~!~$spc  * ~!~$spc  2 ~!~$spc  0bacb 7fa 0 8 2fef 3 0 7 8 2 2 1 1 9 3 8bc 1c 5e 7 0 4 1 6ff 4 4 ~!~$spc  * ~!~$spc  3 ~!~$spc  6 6c 2 8 2 2 7d 0 3a 2d 5 5 2 9 2 6 2ff 0 1 6a 1e 6ef 7 6 5 5 7ece ~!~$spc  * ~!~$spc  4 ~!~$spc a 9 0 4c 9 0 0a 6 4b 3 5 9 0 9 8 7 4b 3 3e 6 1c 5 9 3 8a 8e 1 5ed 1c ~!~$spc  * ~!~$spc  5 ~!~$spc a 3 7e 7 8 3d 7b 7 2 3 3c 0 8 3d 4f 6 2 9 2 6c 7a 2 5f 2 3 8d 0 3 1 6 ~!~$spc  * ~!~$spc  6 ~!~$spc bc 9cd 2 8 5 6 1 0 4 2c 8 3f 2 1 9 3 2 4d 3c 6 0 7 2 5 6c 0 3 2 7 2ae ~!~$spc  * ~!~$spc  7 ~!~$spc a 4fb 9 6 0c 0bc 0 6e 1eabb 8 0 4e 5b 3 9 7cdc 4b 4 5 5 9 6fa ~!~$spc  * ~!~$spc  8 ~!~$spc  1b 3c 8 9f 6 5e 6c 9e 8 8 3 0 1 2 0 5 2 8 2 3 4 4 3f 0 4 8b 4 3 3 2db ~!~$spc  * ~!~$spc  9 ~!~$spc  1 6 3 7 4 0 9 8 0 9a 6 7 9dc 6 9 8 2 0 7 3 1 0c 8c 7fc 0 7 2 9 0d 9e 5 ~!~$spc  * ~!~$spc  * ~!~$spc  table ~!~$spc  2 ~!~$spc details ~!~$spc for ~!~$spc each ~!~$spc count ~!~$spc the ~!~$spc truncated ~!~$spc values ~!~$spc  ( both ~!~$spc in ~!~$spc  * ~!~$spc hexadecimal ~!~$spc and ~!~$spc decimal  ) ~!~$spc and ~!~$spc then ~!~$spc the ~!~$spc  h o ttoken ~!~$spc value  . ~!~$spc  * ~!~$spc  * ~!~$spc  truncated ~!~$spc  * ~!~$spc counterount ~!~$spc  hexadecimal ~!~$spc  decimal ~!~$spc  h o ttoken ~!~$spc  * ~!~$spc  0 ~!~$spc  4c 9 3cf 1 8 ~!~$spc  1 2 8 4 7 5 5 2 2 4 ~!~$spc  7 5 5 2 2 4 ~!~$spc  * ~!~$spc  1 ~!~$spc  4 1 3 9 7eea ~!~$spc  1 0 9 4 2 8 7 0 8 2 ~!~$spc  2 8 7 0 8 2 ~!~$spc  * ~!~$spc  2 ~!~$spc  8 2fef 3 0 ~!~$spc  1 3 7 3 5 9 1 5 2 ~!~$spc  3 5 9 1 5 2 ~!~$spc  * ~!~$spc  3 ~!~$spc  6 6ef 7 6 5 5 ~!~$spc  1 7 2 6 9 6 9 4 2 9 ~!~$spc  9 6 9 4 2 9 ~!~$spc  * ~!~$spc  4 ~!~$spc  6 1c 5 9 3 8a ~!~$spc  1 6 4 0 3 3 8 3 1 4 ~!~$spc  3 3 8 3 1 4 ~!~$spc  * ~!~$spc  5 ~!~$spc  3 3c 0 8 3d 4 ~!~$spc  8 6 8 2 5 4 6 7 6 ~!~$spc  2 5 4 6 7 6 ~!~$spc  * ~!~$spc  6 ~!~$spc  7 2 5 6c 0 3 2 ~!~$spc  1 9 1 8 2 8 7 9 2 2 ~!~$spc  2 8 7 9 2 2 ~!~$spc  * ~!~$spc  7 ~!~$spc  4e 5b 3 9 7 ~!~$spc  8 2 1 6 2 5 8 3 ~!~$spc  1 6 2 5 8 3 ~!~$spc  * ~!~$spc  8 ~!~$spc  2 8 2 3 4 4 3f ~!~$spc  6 7 3 3 9 9 8 7 1 ~!~$spc  3 9 9 8 7 1 ~!~$spc  * ~!~$spc  9 ~!~$spc  2 6 7 9dc 6 9 ~!~$spc  6 4 5 5 2 0 4 8 9 ~!~$spc  5 2 0 4 8 9 ~!~$spc  * ~!~$spc  * ~!~$spc  * ~!~$spc see ~!~$spc http  :  /  / tools  . ietf  . org  / html  / rfc 4 2 2 6 ~!~$spc  *  / ~!~$spc exports  . test h o t p ~!~$spc  = ~!~$spc function  (  ) ~!~$spc  { ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  ; ~!~$spc var ~!~$spc opt ~!~$spc  = ~!~$spc  { ~!~$spc window ~!~$spc  : ~!~$spc  0  , ~!~$spc  }  ; ~!~$spc var ~!~$spc ~!~$all_caps hotp ~!~$spc  = ~!~$spc  [  '  7 5 5 2 2 4  '  , ~!~$spc  '  2 8 7 0 8 2  '  ,  '  3 5 9 1 5 2  '  , ~!~$spc  '  9 6 9 4 2 9  '  , ~!~$spc  '  3 3 8 3 1 4  '  , ~!~$spc  '  2 5 4 6 7 6  '  , ~!~$spc  '  2 8 7 9 2 2  '  , ~!~$spc  '  1 6 2 5 8 3  '  , ~!~$spc  '  3 9 9 8 7 1  '  , ~!~$spc  '  5 2 0 4 8 9  '  ]  ; ~!~$spc  /  / ~!~$spc make ~!~$spc sure ~!~$spc we ~!~$spc can ~!~$spc not ~!~$spc pass ~!~$spc in ~!~$spc opt ~!~$spc notp  . hotp  . verify  (  ' ~!~$all_caps will ~!~$spc ~!~$all_caps not ~!~$spc ~!~$all_caps pass  '  , ~!~$spc key  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc failure ~!~$spc opt  . counter ~!~$spc  = ~!~$spc  0  ; ~!~$spc assert  . ok  (  ! notp  . hotp  . verify  (  ' ~!~$all_caps will ~!~$spc ~!~$all_caps not ~!~$spc ~!~$all_caps pass  '  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc not ~!~$spc pass  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc passes ~!~$spc for  ( i  =  0  ; i  < ~!~$all_caps hotp  . length  ; i  +  +  ) ~!~$spc  { ~!~$spc opt  . counter ~!~$spc  = ~!~$spc i  ; ~!~$spc var ~!~$spc res ~!~$spc  = ~!~$spc notp  . hotp  . verify  ( ~!~$all_caps hotp  [ i  ]  , ~!~$spc key  , ~!~$spc opt  )  ; ~!~$spc assert  . ok  ( res  , ~!~$spc  '  should ~!~$spc pass  '  )  ; ~!~$spc assert  . equal  ( res  . delta  , ~!~$spc  0  , ~!~$spc  '  should ~!~$spc be ~!~$spc in ~!~$spc sync  '  )  ; ~!~$spc  } ~!~$spc  }  ; ~!~$spc  /  * ~!~$spc  * ~!~$spc  test ~!~$spc  t o ttoken ~!~$spc using ~!~$spc test ~!~$spc vectors ~!~$spc from ~!~$spc  t o ttoken ~!~$spc  r fcounter  . ~!~$spc  * ~!~$spc  * ~!~$spc see ~!~$spc http  :  /  / tools  . ietf  . org  / id  / draft  - mraihi  - totp  - timebased  -  0 6  . txt ~!~$spc  *  / ~!~$spc exports  . test t o ttoken ~!~$spc  = ~!~$spc function  (  ) ~!~$spc  { ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  ; ~!~$spc var ~!~$spc opt ~!~$spc  = ~!~$spc  { ~!~$spc window ~!~$spc  : ~!~$spc  0  , ~!~$spc  }  ; ~!~$spc  /  / ~!~$spc make ~!~$spc sure ~!~$spc we ~!~$spc can ~!~$spc not ~!~$spc pass ~!~$spc in ~!~$spc opt ~!~$spc notp  . totp  . verify  ( token  , ~!~$spc key  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc failure ~!~$spc opt  . time ~!~$spc  = ~!~$spc  0  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  ' window i l l n o ttoken a s s  '  ; ~!~$spc assert  . ok  (  ! notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc not ~!~$spc pass  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  5 9s ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  5 9  *  1 0 0 0  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  '  2 8 7 0 8 2  '  ; ~!~$spc var ~!~$spc res ~!~$spc  = ~!~$spc notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ; ~!~$spc assert  . ok  ( res  , ~!~$spc  '  should ~!~$spc pass  '  )  ; ~!~$spc assert  . equal  ( res  . delta  , ~!~$spc  0  , ~!~$spc  '  should ~!~$spc be ~!~$spc in ~!~$spc sync  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  1 2 3 4 5 6 7 8 9 0 ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  1 2 3 4 5 6 7 8 9 0  *  1 0 0 0  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  '  0 0 5 9 2 4  '  ; ~!~$spc var ~!~$spc res ~!~$spc  = ~!~$spc notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ; ~!~$spc assert  . ok  ( res  , ~!~$spc  '  should ~!~$spc pass  '  )  ; ~!~$spc assert  . equal  ( res  . delta  , ~!~$spc  0  , ~!~$spc  '  should ~!~$spc be ~!~$spc in ~!~$spc sync  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  1 1 1 1 1 1 1 1 0 9 ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  1 1 1 1 1 1 1 1 0 9  *  1 0 0 0  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  '  0 8 1 8 0 4  '  ; ~!~$spc var ~!~$spc res ~!~$spc  = ~!~$spc notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ; ~!~$spc assert  . ok  ( res  , ~!~$spc  '  should ~!~$spc pass  '  )  ; ~!~$spc assert  . equal  ( res  . delta  , ~!~$spc  0  , ~!~$spc  '  should ~!~$spc be ~!~$spc in ~!~$spc sync  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  2 0 0 0 0 0 0 0 0 0 ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  2 0 0 0 0 0 0 0 0 0  *  1 0 0 0  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  '  2 7 9 0 3 7  '  ; ~!~$spc var ~!~$spc res ~!~$spc  = ~!~$spc notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  ; ~!~$spc assert  . ok  ( res  , ~!~$spc  '  should ~!~$spc pass  '  )  ; ~!~$spc assert  . equal  ( res  . delta  , ~!~$spc  0  , ~!~$spc  '  should ~!~$spc be ~!~$spc in ~!~$spc sync  '  )  ; ~!~$spc  }  ; ~!~$spc  /  * ~!~$spc  * ~!~$spc counterheck ~!~$spc for ~!~$spc codes ~!~$spc that ~!~$spc are ~!~$spc out ~!~$spc of ~!~$spc sync ~!~$spc  * ~!~$spc windowe ~!~$spc are ~!~$spc going ~!~$spc to ~!~$spc use ~!~$spc a ~!~$spc value ~!~$spc of ~!~$spc counter ~!~$spc  = ~!~$spc  1 ~!~$spc and ~!~$spc test ~!~$spc against ~!~$spc  * ~!~$spc a ~!~$spc code ~!~$spc for ~!~$spc counter ~!~$spc  = ~!~$spc  9 ~!~$spc  *  / ~!~$spc exports  . test h o t p out of sync ~!~$spc  = ~!~$spc function  (  ) ~!~$spc  { ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  '  5 2 0 4 8 9  '  ; ~!~$spc var ~!~$spc opt ~!~$spc  = ~!~$spc  { ~!~$spc counter ~!~$spc  : ~!~$spc  1 ~!~$spc  }  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc that ~!~$spc the ~!~$spc test ~!~$spc should ~!~$spc fail ~!~$spc for ~!~$spc window ~!~$spc  < ~!~$spc  8 ~!~$spc opt  . window ~!~$spc  = ~!~$spc  7  ; ~!~$spc assert  . ok  (  ! notp  . hotp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc not ~!~$spc pass ~!~$spc for ~!~$spc value ~!~$spc of ~!~$spc window ~!~$spc  < ~!~$spc  8  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc that ~!~$spc the ~!~$spc test ~!~$spc should ~!~$spc pass ~!~$spc for ~!~$spc window ~!~$spc  >  = ~!~$spc  9 ~!~$spc opt  . window ~!~$spc  = ~!~$spc  8  ; ~!~$spc assert  . ok  ( notp  . hotp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc pass ~!~$spc for ~!~$spc value ~!~$spc of ~!~$spc window ~!~$spc  >  = ~!~$spc  9  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc that ~!~$spc test ~!~$spc should ~!~$spc pass ~!~$spc for ~!~$spc negative ~!~$spc counter ~!~$spc values ~!~$spc token ~!~$spc  = ~!~$spc  '  7 5 5 2 2 4  '  ; ~!~$spc opt  . counter ~!~$spc  = ~!~$spc  7 ~!~$spc opt  . window ~!~$spc  = ~!~$spc  8  ; ~!~$spc assert  . ok  ( notp  . hotp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc pass ~!~$spc for ~!~$spc negative ~!~$spc counter ~!~$spc values  '  )  ; ~!~$spc  }  ; ~!~$spc  /  * ~!~$spc  * ~!~$spc counterheck ~!~$spc for ~!~$spc codes ~!~$spc that ~!~$spc are ~!~$spc out ~!~$spc of ~!~$spc sync ~!~$spc  * ~!~$spc windowe ~!~$spc are ~!~$spc going ~!~$spc to ~!~$spc use ~!~$spc a ~!~$spc value ~!~$spc of ~!~$spc ~!~$all_caps t ~!~$spc  = ~!~$spc  1 9 9 9 9 9 9 9 0 9 ~!~$spc  (  9 1s ~!~$spc behind ~!~$spc  2 0 0 0 0 0 0 0 0 0  ) ~!~$spc  *  / ~!~$spc exports  . test t o t p out of sync ~!~$spc  = ~!~$spc function  (  ) ~!~$spc  { ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  ; ~!~$spc var ~!~$spc token ~!~$spc  = ~!~$spc  '  2 7 9 0 3 7  '  ; ~!~$spc var ~!~$spc opt ~!~$spc  = ~!~$spc  { ~!~$spc   t ~!~$spc  : ~!~$spc  1 9 9 9 9 9 9 9 0 9  *  1 0 0 0 ~!~$spc  }  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc that ~!~$spc the ~!~$spc test ~!~$spc should ~!~$spc fail ~!~$spc for ~!~$spc window ~!~$spc  < ~!~$spc  2 ~!~$spc opt  . window ~!~$spc  = ~!~$spc  2  ; ~!~$spc assert  . ok  (  ! notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc not ~!~$spc pass ~!~$spc for ~!~$spc value ~!~$spc of ~!~$spc window ~!~$spc  < ~!~$spc  3  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc that ~!~$spc the ~!~$spc test ~!~$spc should ~!~$spc pass ~!~$spc for ~!~$spc window ~!~$spc  >  = ~!~$spc  3 ~!~$spc opt  . window ~!~$spc  = ~!~$spc  3  ; ~!~$spc assert  . ok  ( notp  . totp  . verify  ( token  , ~!~$spc key  , ~!~$spc opt  )  , ~!~$spc  '  should ~!~$spc pass ~!~$spc for ~!~$spc value ~!~$spc of ~!~$spc window ~!~$spc  >  = ~!~$spc  3  '  )  ; ~!~$spc  }  ; ~!~$spc exports  . hotp   gen ~!~$spc  = ~!~$spc function  (  ) ~!~$spc  { ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  ; ~!~$spc var ~!~$spc opt ~!~$spc  = ~!~$spc  { ~!~$spc window ~!~$spc  : ~!~$spc  0  , ~!~$spc  }  ; ~!~$spc var ~!~$spc ~!~$all_caps hotp ~!~$spc  = ~!~$spc  [  '  7 5 5 2 2 4  '  , ~!~$spc  '  2 8 7 0 8 2  '  ,  '  3 5 9 1 5 2  '  , ~!~$spc  '  9 6 9 4 2 9  '  , ~!~$spc  '  3 3 8 3 1 4  '  , ~!~$spc  '  2 5 4 6 7 6  '  , ~!~$spc  '  2 8 7 9 2 2  '  , ~!~$spc  '  1 6 2 5 8 3  '  , ~!~$spc  '  3 9 9 8 7 1  '  , ~!~$spc  '  5 2 0 4 8 9  '  ]  ; ~!~$spc  /  / ~!~$spc make ~!~$spc sure ~!~$spc we ~!~$spc can ~!~$spc not ~!~$spc pass ~!~$spc in ~!~$spc opt ~!~$spc notp  . hotp  . gen  ( key  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc passes ~!~$spc for  ( i  =  0  ; i  < ~!~$all_caps hotp  . length  ; i  +  +  ) ~!~$spc  { ~!~$spc opt  . counter ~!~$spc  = ~!~$spc i  ; ~!~$spc assert  . equal  ( notp  . hotp  . gen  ( key  , ~!~$spc opt  )  , ~!~$spc ~!~$all_caps hotp  [ i  ]  , ~!~$spc  ' ~!~$all_caps hotp ~!~$spc value ~!~$spc should ~!~$spc be ~!~$spc correct  '  )  ; ~!~$spc  } ~!~$spc  }  ; ~!~$spc exports  . totp   gen ~!~$spc  = ~!~$spc function  (  ) ~!~$spc  { ~!~$spc var ~!~$spc key ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  ; ~!~$spc var ~!~$spc opt ~!~$spc  = ~!~$spc  { ~!~$spc window ~!~$spc  : ~!~$spc  0  , ~!~$spc  }  ; ~!~$spc  /  / ~!~$spc make ~!~$spc sure ~!~$spc we ~!~$spc can ~!~$spc not ~!~$spc pass ~!~$spc in ~!~$spc opt ~!~$spc notp  . totp  . gen  ( key  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  5 9s ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  5 9  *  1 0 0 0  ; ~!~$spc assert  . equal  ( notp  . totp  . gen  ( key  , ~!~$spc opt  )  , ~!~$spc  '  2 8 7 0 8 2  '  , ~!~$spc  '  t o ttoken ~!~$spc values ~!~$spc should ~!~$spc match  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  1 2 3 4 5 6 7 8 9 0 ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  1 2 3 4 5 6 7 8 9 0  *  1 0 0 0  ; ~!~$spc assert  . equal  ( notp  . totp  . gen  ( key  , ~!~$spc opt  )  , ~!~$spc  '  0 0 5 9 2 4  '  , ~!~$spc  '  t o ttoken ~!~$spc values ~!~$spc should ~!~$spc match  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  1 1 1 1 1 1 1 1 0 9 ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  1 1 1 1 1 1 1 1 0 9  *  1 0 0 0  ; ~!~$spc assert  . equal  ( notp  . totp  . gen  ( key  , ~!~$spc opt  )  , ~!~$spc  '  0 8 1 8 0 4  '  , ~!~$spc  '  t o ttoken ~!~$spc values ~!~$spc should ~!~$spc match  '  )  ; ~!~$spc  /  / ~!~$spc counterheck ~!~$spc for ~!~$spc test ~!~$spc vector ~!~$spc at ~!~$spc  2 0 0 0 0 0 0 0 0 0 ~!~$spc opt  .   t ~!~$spc  = ~!~$spc  2 0 0 0 0 0 0 0 0 0  *  1 0 0 0  ; ~!~$spc assert  . equal  ( notp  . totp  . gen  ( key  , ~!~$spc opt  )  , ~!~$spc  '  2 7 9 0 3 7  '  , ~!~$spc  '  t o ttoken ~!~$spc values ~!~$spc should ~!~$spc match  '  )  ; ~!~$spc  }  ; ~!~$spc ~!~$start_folder examples ~!~$stop ~!~$start_file examples / TOTP . js ~!~$stop ~!~$spc var ~!~$spc notp ~!~$spc  = ~!~$spc require  (  '  .  .  / index  '  )  , ~!~$spc t 2 ~!~$spc  = ~!~$spc require  (  ' thirty  - two  '  )  , ~!~$spc ~!~$all_caps k ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  , ~!~$spc b 3 2 ~!~$spc  = ~!~$spc t 2  . encode  ( ~!~$all_caps k  )  ; ~!~$spc console  . log  (  '  getting ~!~$spc current ~!~$spc counter ~!~$spc value ~!~$spc for ~!~$spc ~!~$all_caps k ~!~$spc  = ~!~$spc  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  )  ; ~!~$spc console  . log  (  '  this ~!~$spc has ~!~$spc a ~!~$spc base 3 2 ~!~$spc value ~!~$spc of ~!~$spc  ' ~!~$spc  + ~!~$spc b 3 2  )  ; ~!~$spc console  . log  (  '  the ~!~$spc base 3 2 ~!~$spc value ~!~$spc should ~!~$spc be ~!~$spc entered ~!~$spc in ~!~$spc the ~!~$spc  google ~!~$spc  authenticator ~!~$spc  app  '  )  ; ~!~$spc console  . log  (  '  '  )  ; ~!~$spc console  . log  (  '  open ~!~$spc the ~!~$spc following ~!~$spc ~!~$all_caps url ~!~$spc for ~!~$spc a ~!~$spc ~!~$all_caps qr ~!~$spc code  . ~!~$spc  google ~!~$spc  authenticator ~!~$spc can ~!~$spc read ~!~$spc this ~!~$spc ~!~$all_caps qr ~!~$spc code ~!~$spc using ~!~$spc your ~!~$spc phone  \  ' s ~!~$spc camera  :  '  )  ; ~!~$spc console  . log  (  ' http  :  /  / qrcode  . kaywa  . com  / img  . php  ? s  =  8  & d  =  ' ~!~$spc  + ~!~$spc encode u r i component  (  ' otpauth  :  /  / totp  / notp  @ example  . com  ? secret  =  ' ~!~$spc  + ~!~$spc b 3 2  )  )  ; ~!~$spc console  . log  (  '  the ~!~$spc current ~!~$spc ~!~$all_caps totp ~!~$spc value ~!~$spc is ~!~$spc  ' ~!~$spc  + ~!~$spc notp  . totp  . gen  ( ~!~$all_caps k  , ~!~$spc  {  }  )  )  ; ~!~$spc ~!~$start_file examples / TOTP-verify . js ~!~$stop ~!~$spc var ~!~$spc notp ~!~$spc  = ~!~$spc require  (  '  .  .  / index  '  )  , ~!~$spc t 2 ~!~$spc  = ~!~$spc require  (  ' thirty  - two  '  )  , ~!~$spc ~!~$all_caps k ~!~$spc  = ~!~$spc  '  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0  '  , ~!~$spc b 3 2 ~!~$spc  = ~!~$spc t 2  . encode  ( ~!~$all_caps k  )  ; ~!~$spc console  . log  (  '  click ~!~$spc on ~!~$spc this ~!~$spc link ~!~$spc to ~!~$spc gennerate ~!~$spc a ~!~$spc ~!~$all_caps qr ~!~$spc code  , ~!~$spc and ~!~$spc use ~!~$spc  google ~!~$spc  authenticator ~!~$spc on ~!~$spc your ~!~$spc phone ~!~$spc to ~!~$spc read ~!~$spc it  :  '  )  ; ~!~$spc console  . log  (  ' http  :  /  / qrcode  . kaywa  . com  / img  . php  ? s  =  8  & d  =  ' ~!~$spc  + ~!~$spc encode u r i component  (  ' otpauth  :  /  / totp  / notp  @ example  . com  ? secret  =  ' ~!~$spc  + ~!~$spc b 3 2  )  )  ; ~!~$spc verify  (  )  ; ~!~$spc function ~!~$spc verify  (  ) ~!~$spc  { ~!~$spc ask  (  '  enter ~!~$spc a ~!~$spc code ~!~$spc to ~!~$spc verify  '  , ~!~$spc function  ( code  ) ~!~$spc  { ~!~$spc if  ( notp  . totp  . verify  ( code  , ~!~$spc ~!~$all_caps k  , ~!~$spc  {  }  )  ) ~!~$spc  { ~!~$spc console  . log  (  '  success  !  !  !  '  )  ; ~!~$spc  } ~!~$spc console  . log  ( notp  . totp  . verify  ( code  , ~!~$spc ~!~$all_caps k  , ~!~$spc  {  }  )  )  ; ~!~$spc verify  (  )  ; ~!~$spc  }  )  ; ~!~$spc  } ~!~$spc function ~!~$spc ask  ( question  , ~!~$spc callback  ) ~!~$spc  { ~!~$spc var ~!~$spc stdin ~!~$spc  = ~!~$spc process  . stdin  , ~!~$spc stdout ~!~$spc  = ~!~$spc process  . stdout  ; ~!~$spc stdin  . resume  (  )  ; ~!~$spc stdout  . write  ( question ~!~$spc  + ~!~$spc  "  : ~!~$spc  "  )  ; ~!~$spc stdin  . once  (  ' data  '  , ~!~$spc function  ( data  ) ~!~$spc  { ~!~$spc data ~!~$spc  = ~!~$spc data  . to string  (  )  . trim  (  )  ; ~!~$spc callback  ( data  )  ; ~!~$spc  }  )  ; ~!~$spc  } ~!~$spc